1. First we will make connection to our database in the file db.js(config/db.js)
2.we are going to set the .env file where we will save our secure data like db url jwt_secert and other api kyes
3.we will create a model folder and inside it we will make user.js where we are going to make the schema of user 
4. we are  not going to ask user their role when login bc it is risk and 
5.we are going to make the bcrypt mongosee pre function so when ever we will save pass word it will automatically save the user password in hashed form we are going to use mongoose (pre-save middleware)
6.Now we are going to use the compare password so when the user login or wants to updates he needs to give password so we will make a function matchPassword() so we can call it and use whenever we needed instead of making every time .Inside the user.js

7.we will generate jwt token inside our genreateTokens.js which  we will use when we are setting cookies and this token will be sent to browser so when the user again visit with in the setted time it will allow user to login with giving login credentials


8. we will make the controlles folder first we will make cookies here and then use these cookies in routes  where will make the core logic of routes we will 

9.we are going to use the multer to file upload and using cloudnairy to store the file and its gives us url which we store in database

10.strategy :
            user will upload the file using multer and we temporaly store that at memory means ram then using cloudinary we will get the file from there and upload to the cloudinary 


11.this is for disk storage
multer.js
// multer.js
const multer = require("multer");
const path = require("path");
const fs = require("fs");

// Temp folder for uploads
const uploadPath = path.join(__dirname, "../public/temp");

// Create folder if it doesn't exist
if (!fs.existsSync(uploadPath)) {
  fs.mkdirSync(uploadPath, { recursive: true });
}

// Disk storage
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    const uniqueName =
      Date.now() + "-" + Math.round(Math.random() * 1e9) + path.extname(file.originalname);
    cb(null, uniqueName);
  },
});

// Multer instance
const upload = multer({
  storage,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB limit
  },
});

module.exports = upload;

cloudinary.js// cloudinary.js
const cloudinary = require("cloudinary").v2;
const fs = require("fs/promises");

// Cloudinary config
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// Upload function
const uploadOnCloudinary = async (localFilePath, options = {}) => {
  if (!localFilePath) return null;

  try {
    const response = await cloudinary.uploader.upload(localFilePath, {
      resource_type: "auto",
      folder: options.folder || "uploads",
      quality: "auto",
      fetch_format: "auto",
      overwrite: false,
      invalidate: true,
      unique_filename: true,
      transformation: [
        { quality: "auto", fetch_format: "auto" },
        { width: 1200, height: 1200, crop:  limit" },
      ],
      ...options,
    });

    console.log("Upload successful:", response.secure_url);

    // Delete local temp file after upload
    await fs.unlink(localFilePath).catch(() => {});

    return {
      url: response.secure_url,
      public_id: response.public_id,
      format: response.format,
      width: response.width,
      height: response.height,
    };
  } catch (error) {
    console.error("Cloudinary upload failed:", error.message);
    await fs.unlink(localFilePath).catch(() => {});
    return null;
  }
};

module.exports = uploadOnCloudinary;


route.js// routes.js
const express = require("express");
const router = express.Router();
const upload = require("./multer"); // multer diskStorage
const uploadOnCloudinary = require("./cloudinary");

// Single image upload route
router.post("/upload", upload.single("image"), async (req, res) => {
  try {
    if (!req.file) return res.status(400).json({ message: "No file uploaded" });

    // ✅ Use multer's req.file.path as localFilePath
    const localFilePath = req.file.path;  // if we hav multiples images like we used the fields we have to do                   const localFilePath = req.files?.avatar[0]?.path   Returns the full file path on the server where Multer saved it:   bc upload.fields([]) is used  

    //we write 0 bc insde fild it store the images in form of array so thats why we do [0].path

    const result = await uploadOnCloudinary(localFilePath, { folder: "products" });

    if (!result) return res.status(500).json({ message: "Cloudinary upload failed" });

    res.status(200).json({
      message: "File uploaded successfully",
      data: result,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "Server error" });
  }
});

module.exports = router;



server.js// server.js
const express = require("express");
const app = express();
const routes = require("./routes");
require("dotenv").config();

// Middleware
app.use(express.json());
app.use("/public", express.static("public")); // optional, serve temp folder if needed

// Routes
app.use("/api", routes);

// Start server
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));


//logic 
req.file.filename = uniqueName;        // just the filename
req.file.path = destination + "/" + uniqueName;  // full local path
req.file = {
  originalname: 'cat.jpg',
  filename: '1675212345678-345678901.jpg', // your uniqueName
  path: 'public/temp/1675212345678-345678901.jpg', // full path
  destination: 'public/temp',
  size: 34567,
  mimetype: 'image/jpeg'
};

const localFilePath = req.file.path; // full path
const result = await uploadOnCloudinary(localFilePath);




// We can use this authController.js if we want to allow direct login after user register no need to logi 
(
  
const User = require("../models/User");
const generateToken = require("../utils/generateToken");

const sendCookie = (res, token) => {
  res.cookie("token", token, {
    httpOnly: true,
    sameSite: "strict",
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
  });
};

// Helper to return safe user data
const getSafeUser = (user) => ({
  _id: user._id,
  name: user.name,
  email: user.email,
  role: user.role,
});

exports.register = async (req, res) => {
  try {
    const { name, email, password, role } = req.body;

    // Basic validation
    if (!name || !email || !password) {
      return res.status(400).json({ message: "All fields are required" });
    }

    // Check if user already exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(409).json({ message: "User already exists" });
    }

    // Create user
    const user = await User.create({
      name,
      email,
      password,
      role: role || "customer",
    });

    // Generate token & send cookie
    const token = generateToken(user);
    sendCookie(res, token);

    // Send safe user data
    res.status(201).json({
      message: "Registration successful",
      user: getSafeUser(user),
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ message: "Email and password required" });
    }

    const user = await User.findOne({ email }).select("+password");

    if (!user || !(await user.matchPassword(password))) {
      return res.status(401).json({ message: "Invalid credentials" });
    }

    const token = generateToken(user);
    sendCookie(res, token);

    res.json({
      message: "Login successful",
      user: getSafeUser(user),
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

exports.logout = (req, res) => {
  res.cookie("token", "", { httpOnly: true, expires: new Date(0) });
  res.json({ message: "Logged out successfully" });
};

exports.me = (req, res) => {
  res.json(getSafeUser(req.user));
};

)


till 1 date we created only register and login we will continue further


SQL	MongoDB Aggregation
SELECT	$project
WHERE	$match
GROUP BY	$group
JOIN	$lookup
HAVING	$match (after $group)
ORDER BY	$sort
LIMIT	$limit


//we can also use this exports.getSellerOrders = async (req, res) => {
  try {
    const userId = req.user?._id;
    const role = req.user?.role;

    if (!userId) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    if (role !== "seller") {
      return res.status(403).json({ message: "Only sellers can access this route" });
    }

    // Convert logged-in seller id to ObjectId
    const sellerId = new mongoose.Types.ObjectId(userId);

    const page = Math.max(1, Number(req.query.page) || 1);
    const limit = Math.min(100, Math.max(1, Number(req.query.limit) || 10));
    const skip = (page - 1) * limit;

    const orders = await Order.aggregate([
      // Step 1: Filter only orders that are paid and contain seller's items and it will give us all items including different sellerId and will give all orders not one
      {
        $match: {
          paymentStatus: "paid",
          "items.seller": sellerId
        }
      },
      // Step 2: Keep only seller's items and necessary fields the result form previous stage will be given to this and here we are using project it is like select and we want speific customer at the time he paid and items also but only those items  in order that are created by the seller so we are using seller id to mathc 
      {
        $project: {
          customer: 1,
          paidAt: 1, // Use your paidAt field instead of createdAt
          items: {
            $filter: {
              input: "$items", //The array we want to filter
              as: "item", //The signle item in array
              cond: { $eq: ["$$item.seller", sellerId] }  //double dollor represent that item is variable of the filter
            }
          }
        }
      },
      // Step 3: Lookup customer details from users collection
      {
        $lookup: {
          from: "users",          // collection to join
          localField: "customer", // field in orders
          foreignField: "_id",    // field in users
          as: "customer"          // store matched user info here
        }
      },
      // Step 4: Convert customer array to single object
      { $unwind: "$customer" },
      {
        $project: {
          paidAt: 1,
          items: 1,
          customer: {
            _id: "$customer._id",
            name: "$customer.name",
            email: "$customer.email"
          }
        }
      },
      { $sort: { paidAt: -1, _id: -1 } },
      { $skip: skip },
      { $limit: limit }
    ]);

    res.json({ page, limit, count: orders.length, orders });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

we can also use this 
const mongoose = require("mongoose");
const Order = require("../models/Order");

// GET seller orders
exports.getSellerOrders = async (req, res) => {
  try {
    const sellerId = new mongoose.Types.ObjectId(req.user._id);

    const orders = await Order.aggregate([
      // 1️⃣ Match paid orders containing this seller
      {
        $match: {
          paymentStatus: "paid",
          "items.seller": sellerId
        }
      },
      // 2️⃣ Unwind items array
      { $unwind: "$items" },
      // 3️⃣ Keep only seller's items
      { $match: { "items.seller": sellerId } },
      // 4️⃣ Lookup product details
      {
        $lookup: {
          from: "products",
          localField: "items.product",
          foreignField: "_id",
          as: "product"
        }
      },
      { $unwind: "$product" },
      // 5️⃣ Lookup customer details
      {
        $lookup: {
          from: "users",
          localField: "customer",
          foreignField: "_id",
          as: "customer"
        }
      },
      { $unwind: "$customer" },
      // 6️⃣ Project only needed fields
      {
        $project: {
          orderId: "$_id",
          paidAt: 1,
          productName: "$product.title",
          quantity: "$items.quantity",
          price: "$items.price",
          shipped: "$items.status",
          customerName: "$customer.name",
          customerEmail: "$customer.email"
        }
      }
    ]);

    res.json({ orders });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Failed to fetch orders", error: error.message });
  }
};
